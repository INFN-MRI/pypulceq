"""Porting of TOPPE preflightcheck."""

__all__ = ["preflightcheck"]

from os.path import realpath, sep

import numpy as np

from ._read import _readmodulelistfile
from ._read import _readmod
from ._read import _readloop

from . import utils


def preflightcheck(entryFile, seqstampFile, sysGE):
    """
    Generate a 'sequence stamp' file containing file checksums and safety information.

    This function loads various TOPPE files listed in the `entryFile` and the file listed
    in line 2 of `entryFile` (e.g., 'modules.txt') and populates `seqstampFile` with
    miscellaneous sequence information related to peak gradient/slew, peak 10-sec SAR
    (equivalent TR), and gradient heating. The various files listed in `entryFile` and
    `modules.txt` must be present in the current working folder.

    Parameters
    ----------
    entryFile : str
        The entry point file for the TOPPE interpreter. It must be copied
        to /usr/g/research/pulseq/ on the scanner host. The various files listed in
        `entryFile` and `modules.txt` must be present in the current working folder.
        See https://github.com/toppeMRI/toppe/blob/main/Files.md for details.
    seqstampFile : str
        The output file name. It must be listed in line 6 of `entryFile`.
    sysGE : dict
        GE system struct. See toppe.systemspecs().

    Example
    -------
    Step 1: Create the file 'toppe0.entry' by hand and copy it to /usr/g/research/pulseq/
    on the scanner host computer. See examples/3DGRE/ for an example.
    Step 2: Define the system hardware parameters.
        >>> sys = toppe.systemspecs()  # Use default system limits. This is usually not a good idea!
    Step 3: Create the file 'seqstamp.txt'.
        >>> preflightcheck('toppe0.entry', 'seqstamp.txt', sys)
    Step 4: Copy all scan files to the scanner host computer, in the path stated in
    line 1 of toppe0.entry. For the 3D GRE example, these files are: modules.txt,
    scanloop.txt, tipdown.mod, readout.mod, and seqstamp.txt.
    Step 5: Prescribe the interpreter and scan, following the README in the
    interpreter code repository.

    """
    # Open output file
    with open(seqstampFile, "w") as fout:
        # function name
        funcpath = realpath(__file__)
        funcpath = funcpath.split(sep)[-1]

        # Write file preamble
        fout.write("DO NOT EDIT THIS FILE.\n\n")
        fout.write("Sequence 'stamp' file used by TOPPE interpreter\n")
        fout.write("to perform patient and hardware safety checks.\n")
        fout.write(f"This file was generated by {funcpath}\n\n")

        # Get scan file names
        with open(entryFile, "r") as fid:
            fpath = fid.readline().strip()  # Location of TOPPE scan file
            if not fpath.endswith("/"):
                raise ValueError(f"Path in {entryFile} must end with a slash ('/')")
            moduleListFile = fid.readline().strip()  # e.g., 'modules.txt'
            loopFile = fid.readline().strip()  # e.g., 'scanloop.txt'
            b1CheckFile = (
                fid.readline().strip()
            )  # .mod file used for b1 scaling and SAR checks, e.g., 'tipdown.mod'
            readoutFilterFile = (
                fid.readline().strip()
            )  # .mod file used to set the receive filter, e.g., 'readout.mod'
            seqstampFileFromEntryFile = fid.readline().strip()

        # Check file name consistency
        if seqstampFile != seqstampFileFromEntryFile:
            print(f"seqstamp filename different from that listed in {entryFile}")

        # Get modules.
        # This step also checks the formatting of the module list file.
        modArr = _readmodulelistfile(moduleListFile)

        # Check that:
        # - all .mod files use the same peak RF limit (e.g., 0.25 Gauss)
        # - all .mod files used to acquire data have the same number of ADC samples as readoutFilterFile.
        _, _, _, _, _, _, _, hdr = _readmod(b1CheckFile)
        b1limit = hdr["b1max"]

        _, _, _, _, _, _, _, hdr = _readmod(readoutFilterFile)
        ndaq = hdr["rfres"]  # Number of 4us samples to acquire

        for mod in modArr:
            _, _, _, _, _, _, _, hdr = _readmod(mod["fname"])

            if mod["hasDAQ"] and hdr["rfres"] != ndaq:
                raise ValueError(
                    f"Number of samples in {readoutFilterFile} and {mod['fname']} do not match (must be the same across all .mod files containing ADC windows)"
                )
            if hdr["b1max"] != b1limit:
                raise ValueError(
                    f"B1 limit in {mod['fname']} does not match {entryFile} (must be the same across all .mod files)"
                )

        # Get peak gradient and slew across all .mod files.
        # This also issues any PNS warnings (in checkwaveforms).
        gmax = 0
        slewmax = 0
        for mod in modArr:
            _, gx, gy, gz, _, _, _, _ = _readmod(mod["fname"])
            is_valid, gmaxtmp, slewmaxtmp = utils.checkwaveforms(
                sysGE,
                gx=gx,
                gy=gy,
                gz=gz,
                rfUnit="G",
                gradUnit="G/cm",
                slewUnit="G/cm/msec",
            )

            if not is_valid:
                raise ValueError(f"checkwaveforms failed for {mod['fname']}")

            gmax = max(gmax, max(gmaxtmp))
            slewmax = max(slewmax, max(slewmaxtmp))

        # Write file checksums
        # First check if md5 is present. If not, write a dummy value.
        # [status, cs] = eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', moduleListFile    ))
        cs = "123456789"
        if False:  # isempty(strfind(cs, 'not found'))
            fout.write(f"{cs}")  # cs contains a trailing newline
            cs = "123456789"  # eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', loopFile          )
            fout.write(f"{cs}")
            cs = "123456789"  # eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', b1CheckFile       )
            fout.write(f"{cs}")
            cs = "123456789"  # eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', readoutFilterFile )
            fout.write(f"{cs}")
            fout.write(f"{len(modArr)}\n")  # Number of .mod files ('cores' in .e file)
            for mod in modArr:
                cs = "123456789"  # eval(sprintf('system("md5sum %s | cut -d '' '' -f 1")', mod['fname']))
                fout.write(f"{cs}")
        else:
            fout.write("123456789\n")
            fout.write("123456789\n")
            fout.write("123456789\n")
            fout.write("123456789\n")
            fout.write(f"{len(modArr)}\n")  # Number of .mod files ('cores' in .e file)
            for mod in modArr:
                fout.write("123456789\n")

        # Calculate 'equivalent' TR (TRequiv) corresponding to the worst-case 10-sec SAR.
        # Assumes the use of the RF pulse in 'b1CheckFile'.
        # (TODO: consider replacing with a fixed reference pulse, e.g., 90 deg tbw=6 dur=2.3ms sinc as in 3dgrass.e)
        # To stay within SAR limits, TRequiv must be greater than the value returned by 'maxseqsar' in the EPIC code.
        # Also calculate gradient 'power' = energy per TRequiv.
        # Do it in 10s chunks, in 5s steps.
        loop, loophdr = _readloop(loopFile)
        scanDur = loophdr["scandur"] * 1e-6  # Scan duration, sec

        # peakrfpower = 0
        # peakgxs = 0  # Squared gradient, peak 10s average
        # peakgys = 0
        # peakgzs = 0

        tSpan = 10  # Time span to average over (sec)

        rf, _, _, _, _, _, _, _ = _readmod(b1CheckFile)
        refPulse = {}
        refPulse["energy"] = sum(np.abs(rf) ** 2) * sysGE.raster * 1e-6  # Gauss^2*s

        # Get peak 10s RF power
        maxEnergy = 0
        # msgLast = ''
        print("preflightcheck: Checking max 10s SAR, ")
        for tStart in range(0, 1000, 5):
            msg = f"time interval {tStart}-{tStart+10}s (scan duration: {round(scanDur)}s)\n"
            print(msg, end="")
            rf, gx, gy, gz, tRange = utils.plotseq(
                sysGE, timeRange=[int(tStart), int(tStart) + 10]
            )

            maxEnergy = max(
                maxEnergy, sum(np.abs(rf) ** 2) * sysGE.raster * 1e-6
            )  # Gauss^2 * s

            dur = np.diff(tRange)  # Duration of the span (<= tSpan)
            if tSpan - dur > 2 * sysGE.raster * 1e-6:
                break  # End of scan
        print("\n")

        TRequiv = round(tSpan * 1e6 * refPulse["energy"] / maxEnergy)  # microsec

        # Equivalent TR, and gradient power
        rf, _, _, _, _, _, _, _ = _readmod(b1CheckFile)
        powerx = 0  # (G/cm)^2 * usec.
        powery = 0  # (G/cm)^2 * usec
        powerz = 0  # (G/cm)^2 * usec

        # SAR, relative to a reference scan empirically observed to reach 10s SAR = 6.2 W/kg in a 150 lbs male subject
        E_ref = 2.3514  # RF energy per TR in the reference scan. sum(rf.^2), Gauss^2, for 4us RF raster.
        TR_ref = 12.192e-3  # TR of the reference scan (s)
        P_ref = (
            sysGE.raster * 1e-6 * E_ref / TR_ref
        )  # RF power (Gauss^2) of the reference scan
        P_this = (
            maxEnergy / tSpan
        )  # Peak 10s average RF power (Gauss^2 of the current scan)
        SAR_predicted = P_this / P_ref * 6.2  # W/kg

        # Print various parameters to the file
        fout.write(f"{TRequiv}\n")
        fout.write(
            f"{round(powerx)}\t{round(powery)}\t{round(powerz)}\n"
        )  # Needed in minseq() in the .e file
        fout.write(f"{max(abs(rf)):.4f}\n")  # Needed to scale max_seqsar in .e file
        fout.write(f"{gmax:.4f}\n")  # Max gradient across all .mod files (Gauss)
        fout.write(f"{slewmax:.4f}\n")  # Max slew across all .mod files (G/cm/ms)
        fout.write(f"{b1limit:.4f}\n")  # Hardware b1 limit (Gauss)

        print(
            f"\tPredicted peak 10s SAR in a 150 lbs subject: {SAR_predicted:.1f} W/kg"
        )
        if SAR_predicted > 6.4:
            print("Warning: Predicted peak 10s SAR exceeds first-level limit!!")
